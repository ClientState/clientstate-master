// Generated by CoffeeScript 1.8.0
(function() {
  var App, Container, ProviderLoginDetails, User, bookshelf,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  require('./conn');

  require('./redis_conf');

  require('./docker');

  bookshelf = require('bookshelf')(knexion);

  User = (function(_super) {
    __extends(User, _super);

    function User() {
      return User.__super__.constructor.apply(this, arguments);
    }

    User.prototype.hasTimestamps = true;

    User.prototype.tableName = 'users';

    User.tableName = 'users';

    User.createTable = function(t) {
      t.increments('id');
      t.timestamps();
    };

    User.prototype.logins = function() {
      return this.hasMany(ProviderLoginDetails);
    };

    return User;

  })(bookshelf.Model);

  ProviderLoginDetails = (function(_super) {
    __extends(ProviderLoginDetails, _super);

    function ProviderLoginDetails() {
      return ProviderLoginDetails.__super__.constructor.apply(this, arguments);
    }

    ProviderLoginDetails.prototype.tableName = 'provider_login_details';

    ProviderLoginDetails.tableName = 'provider_login_details';

    ProviderLoginDetails.createTable = function(t) {
      t.string('id').primary();
      t.string('provider');
      t.string('access_token').index().unique();
      t.json('data');
      t.timestamps();
      t.integer('user_id').unsigned().references('id').inTable('users');
    };

    ProviderLoginDetails.prototype.user = function() {
      return this.belongsTo(User);
    };

    return ProviderLoginDetails;

  })(bookshelf.Model);

  App = (function(_super) {
    __extends(App, _super);

    function App() {
      this["delete"] = __bind(this["delete"], this);
      this.save_containers = __bind(this.save_containers, this);
      this.launch_service = __bind(this.launch_service, this);
      return App.__super__.constructor.apply(this, arguments);
    }

    App.prototype.hasTimestamps = true;

    App.prototype.tableName = 'apps';

    App.tableName = 'apps';

    App.createTable = function(t) {
      t.string('id').primary();
      t.string('secret');
      t.string('oauth_redirect_url');
      t.string('name');
      t.timestamps();
      t.integer('user_id').unsigned().references('id').inTable('users');
    };

    App.prototype.user = function() {
      return this.belongsTo(User);
    };

    App.prototype.containers = function() {
      return this.hasMany(Container);
    };

    App.prototype.launch_service = function(opts, cb) {
      var redis_create_options, self;
      self = this;

      /*
       * Assume that we have an images named
       *     skyl/clientstate-service
       *     redis images
       * can build from the submodule - docker/clientstate-service
       * Assume we have a docker client instantiated with Env variables
       *
       * Run redis and link to skyl/clientstate-service
       *
       * https://docs.docker.com/reference/api/docker_remote_api_v1.15/
       */
      redis_create_options = {
        "Image": "redis",
        "ExposedPorts": {
          "6379/tcp": {}
        }
      };
      return docker.createContainer(redis_create_options, function(err, redisContainer) {
        var redis_start_options;
        if (err != null) {
          console.log(err);
          return;
        }
        redis_start_options = {
          "PortBindings": {
            "6379/tcp": {}
          }
        };
        return redisContainer.start(redis_start_options, function(err, data) {
          var GITHUB_CLIENT_ID, GITHUB_CLIENT_SECRET, OAUTH_REDIRECT_URL;
          if (err != null) {
            console.log(err);
            return;
          }
          GITHUB_CLIENT_ID = self.get("id");
          GITHUB_CLIENT_SECRET = self.get("secret");
          OAUTH_REDIRECT_URL = self.get("oauth_redirect_url");
          return redisContainer.inspect(function(err, rcInfo) {
            var cs_create_options;
            if (err != null) {
              console.log(err);
              return;
            }
            cs_create_options = {
              "Image": "skyl/clientstate-service",
              "ExposedPorts": {
                "3000/tcp": {}
              },
              Env: ["GITHUB_CLIENT_ID=" + GITHUB_CLIENT_ID, "GITHUB_CLIENT_SECRET=" + GITHUB_CLIENT_SECRET, "OAUTH_REDIRECT_URL=" + OAUTH_REDIRECT_URL, "DEBUG=yes"]
            };
            return docker.createContainer(cs_create_options, function(err, csContainer) {
              var cs_start_options;
              if (err != null) {
                console.log(err);
                return;
              }
              cs_start_options = {
                "Links": ["" + rcInfo.Name + ":redis"],
                "PortBindings": {
                  "3000/tcp": {}
                }
              };
              return csContainer.start(cs_start_options, function(err, data) {
                return csContainer.inspect(function(err, cscInfo) {
                  redis_client.set(self.id, "" + cscInfo.NetworkSettings.IPAddress + ":3000");
                  return self.save_containers(cscInfo, rcInfo, function() {
                    cb(self);
                  });
                });
              });
            });
          });
        });
      });
    };

    App.prototype.save_containers = function() {
      var args, cb, container, containers_left, _i, _len, _ref, _results;
      args = Array.prototype.slice.call(arguments);
      cb = args[arguments.length - 1];
      containers_left = args.length - 1;
      _ref = args.slice(0, -1);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        container = _ref[_i];
        _results.push(new Container({
          id: container.Id,
          app_id: this.id,
          inspect_info: container
        }).save(null, {
          method: "insert"
        }).then(function() {
          containers_left -= 1;
          if (containers_left === 0) {
            cb();
          }
        }));
      }
      return _results;
    };

    App.prototype["delete"] = function(cb) {
      var self;
      self = this;
      return this.containers().fetch().then(function(collection) {
        var container, dc, _i, _len, _ref;
        _ref = collection.models;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          container = _ref[_i];
          dc = docker.getContainer(container.id);
          dc.stop(function() {
            return dc.remove(function() {});
          });
        }
        return self.destroy().then(cb);
      });
    };

    return App;

  })(bookshelf.Model);

  Container = (function(_super) {
    __extends(Container, _super);

    function Container() {
      return Container.__super__.constructor.apply(this, arguments);
    }

    Container.prototype.tableName = 'containers';

    Container.prototype.hasTimestamps = true;

    Container.prototype.app = function() {
      return this.belongsTo(App);
    };

    Container.tableName = 'containers';

    Container.createTable = function(t) {
      t.string('id').primary();
      t.timestamps();
      t.json('inspect_info');
      t.string('app_id').references('id').inTable('apps').onDelete('CASCADE');
    };

    return Container;

  })(bookshelf.Model);

  global.bookshelf = bookshelf;

  module.exports.User = User;

  module.exports.ProviderLoginDetails = ProviderLoginDetails;

  module.exports.App = App;

  module.exports.Container = Container;

}).call(this);
